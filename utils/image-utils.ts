interface Match {
  yourDeck: string
  opponentDeck: string
  position: "first" | "second"
  result: "win" | "lose"
  timestamp: string
  winStreak: number
  note?: string
}

export function generateTodayReportImage(matches: Match[], t: any): Promise<string> {
  return new Promise((resolve) => {
    const canvas = document.createElement("canvas")
    const ctx = canvas.getContext("2d")!

    // 캔버스 크기 설정 (Instagram 정사각형 비율)
    canvas.width = 800
    canvas.height = 800

    // 배경색 설정
    ctx.fillStyle = "#f8fafc"
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    // 헤더 그리기
    const headerHeight = 120
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, headerHeight)
    gradient.addColorStop(0, "#3b82f6")
    gradient.addColorStop(1, "#1d4ed8")

    ctx.fillStyle = gradient
    ctx.fillRect(0, 0, canvas.width, headerHeight)

    // 헤더 텍스트
    ctx.fillStyle = "white"
    ctx.font = "bold 32px Arial, sans-serif"
    ctx.textAlign = "center"
    ctx.fillText("🎮 Omegagu Report", canvas.width / 2, 45)

    const today = new Date().toLocaleDateString("ko-KR", {
      year: "numeric",
      month: "long",
      day: "numeric",
    })
    ctx.font = "20px Arial, sans-serif"
    ctx.fillText(`${today} 전적`, canvas.width / 2, 80)

    // 게임 리스트 영역
    let yPos = headerHeight + 40
    const gameHeight = 60
    const maxGames = Math.min(matches.length, 8) // 최대 8게임만 표시

    matches.slice(0, maxGames).forEach((match, index) => {
      // 게임 카드 배경
      const cardColor = match.result === "win" ? "#dcfce7" : "#fef2f2"
      const borderColor = match.result === "win" ? "#16a34a" : "#dc2626"

      ctx.fillStyle = cardColor
      ctx.fillRect(40, yPos, canvas.width - 80, gameHeight - 10)

      // 테두리
      ctx.strokeStyle = borderColor
      ctx.lineWidth = 2
      ctx.strokeRect(40, yPos, canvas.width - 80, gameHeight - 10)

      // 결과 아이콘
      const icon = match.result === "win" ? "🟢" : "🔴"
      const resultIcon = match.result === "win" ? "✅" : "❌"

      ctx.fillStyle = "#1f2937"
      ctx.font = "18px Arial, sans-serif"
      ctx.textAlign = "left"

      // 게임 정보 텍스트
      const positionText = match.position === "first" ? "선공" : "후공"
      const gameText = `${icon} ${match.yourDeck} vs ${match.opponentDeck} (${positionText}) ${resultIcon}`

      ctx.fillText(gameText, 60, yPos + 30)

      // 연승 표시
      if (match.winStreak > 1) {
        ctx.fillStyle = "#16a34a"
        ctx.font = "bold 14px Arial, sans-serif"
        ctx.textAlign = "right"
        ctx.fillText(`${match.winStreak}연승!`, canvas.width - 60, yPos + 30)
      }

      yPos += gameHeight
    })

    // 더 많은 게임이 있을 경우 표시
    if (matches.length > maxGames) {
      ctx.fillStyle = "#6b7280"
      ctx.font = "16px Arial, sans-serif"
      ctx.textAlign = "center"
      ctx.fillText(`... 외 ${matches.length - maxGames}게임 더`, canvas.width / 2, yPos + 20)
      yPos += 40
    }

    // 통계 영역
    const statsY = Math.max(yPos + 40, canvas.height - 180)

    // 통계 배경
    ctx.fillStyle = "#f1f5f9"
    ctx.fillRect(40, statsY, canvas.width - 80, 120)
    ctx.strokeStyle = "#cbd5e1"
    ctx.lineWidth = 1
    ctx.strokeRect(40, statsY, canvas.width - 80, 120)

    // 통계 계산
    const wins = matches.filter((m) => m.result === "win").length
    const winRate = matches.length > 0 ? ((wins / matches.length) * 100).toFixed(1) : "0.0"
    const maxStreak = Math.max(...matches.map((m) => m.winStreak), 0)

    // 통계 텍스트
    ctx.fillStyle = "#1f2937"
    ctx.font = "bold 24px Arial, sans-serif"
    ctx.textAlign = "center"
    ctx.fillText(`📊 ${matches.length}게임 | 승률 ${winRate}%`, canvas.width / 2, statsY + 40)

    if (maxStreak > 1) {
      ctx.font = "bold 20px Arial, sans-serif"
      ctx.fillStyle = "#dc2626"
      ctx.fillText(`🔥 ${maxStreak}연승 달성!`, canvas.width / 2, statsY + 75)
    }

    // 워터마크
    ctx.fillStyle = "#9ca3af"
    ctx.font = "14px Arial, sans-serif"
    ctx.textAlign = "center"
    ctx.fillText("Generated by Omegagu", canvas.width / 2, canvas.height - 20)

    // 이미지 데이터 URL 반환
    resolve(canvas.toDataURL("image/png"))
  })
}

export function downloadImage(dataUrl: string, filename: string) {
  const link = document.createElement("a")
  link.download = filename
  link.href = dataUrl
  link.click()
}

export async function copyImageToClipboard(dataUrl: string) {
  try {
    const response = await fetch(dataUrl)
    const blob = await response.blob()
    await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })])
    return true
  } catch (error) {
    console.error("클립보드 복사 실패:", error)
    return false
  }
}
