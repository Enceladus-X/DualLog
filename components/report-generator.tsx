"use client"

import { useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Switch } from "@/components/ui/switch"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { X, Download, Copy, Eye, BarChart3 } from "lucide-react"

interface Match {
  yourDeck: string
  opponentDeck: string
  position: "first" | "second"
  result: "win" | "lose"
  timestamp: string
  winStreak: number
  note?: string
}

interface ReportOptions {
  // í”„ë¼ì´ë²„ì‹œ
  hideDeckNames: boolean
  deckAlias: string
  hideOpponentNames: boolean
  // ì „ì²´ í†µê³„
  showAllTimeStats: boolean
}

interface ReportGeneratorProps {
  todayMatches: Match[]
  allMatches: Match[]
  isOpen: boolean
  onClose: () => void
  t: any
  settings: any
}

const defaultOptions: ReportOptions = {
  hideDeckNames: false,
  deckAlias: "ë‚´ ë±",
  hideOpponentNames: false,
  showAllTimeStats: true,
}

export default function ReportGenerator({
  todayMatches,
  allMatches,
  isOpen,
  onClose,
  t,
  settings,
}: ReportGeneratorProps) {
  const [activeTab, setActiveTab] = useState("text")
  const [options, setOptions] = useState<ReportOptions>(defaultOptions)
  const [textPreview, setTextPreview] = useState("")
  const [imagePreview, setImagePreview] = useState("")
  const [isGenerating, setIsGenerating] = useState(false)

  // í˜„ì¬ ì—°ìŠ¹ ê³„ì‚° (ì˜¤ëŠ˜ ê¸°ì¤€)
  const getCurrentStreak = () => {
    if (todayMatches.length === 0) return 0

    let currentStreak = 0
    for (let i = todayMatches.length - 1; i >= 0; i--) {
      if (todayMatches[i].result === "win") {
        currentStreak++
      } else {
        break
      }
    }
    return currentStreak
  }

  // ì „ì²´ í†µê³„ ê³„ì‚°
  const getAllTimeStats = () => {
    if (allMatches.length === 0) return null

    const wins = allMatches.filter((m) => m.result === "win").length
    const winRate = ((wins / allMatches.length) * 100).toFixed(1)
    const maxStreak = Math.max(...allMatches.map((m) => m.winStreak), 0)

    return {
      totalGames: allMatches.length,
      wins,
      losses: allMatches.length - wins,
      winRate: Number.parseFloat(winRate),
      maxStreak,
    }
  }

  // í…ìŠ¤íŠ¸ ë¦¬í¬íŠ¸ ìƒì„±
  const generateTextReport = () => {
    if (todayMatches.length === 0 && !options.showAllTimeStats) return "ê²Œì„ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤."

    const wins = todayMatches.filter((m) => m.result === "win").length
    const winRate = todayMatches.length > 0 ? ((wins / todayMatches.length) * 100).toFixed(1) : "0.0"
    const currentStreak = getCurrentStreak()
    const today = new Date().toLocaleDateString("ko-KR")
    const allTimeStats = getAllTimeStats()

    let report = ""

    // í—¤ë”
    report += `ğŸ® ${t.appName} ì „ì  ë¦¬í¬íŠ¸\n`
    report += `ğŸ“… ${today}\n`
    report += `${"=".repeat(30)}\n\n`

    // ì „ì²´ í†µê³„ (ì˜µì…˜)
    if (options.showAllTimeStats && allTimeStats) {
      report += `ğŸ“Š ì „ì²´ í†µê³„ (ëˆ„ì )\n`
      report += `â€¢ ì´ ê²Œì„: ${allTimeStats.totalGames}ê²Œì„\n`
      report += `â€¢ ìŠ¹ë¦¬: ${allTimeStats.wins}ê²Œì„ | íŒ¨ë°°: ${allTimeStats.losses}ê²Œì„\n`
      report += `â€¢ ìŠ¹ë¥ : ${allTimeStats.winRate}%\n`
      report += `â€¢ ìµœê³  ì—°ìŠ¹: ${allTimeStats.maxStreak}ì—°ìŠ¹ ğŸ”¥\n\n`
    }

    // ì˜¤ëŠ˜ì˜ ì „ì 
    if (todayMatches.length > 0) {
      report += `ğŸ¯ ì˜¤ëŠ˜ì˜ ì „ì \n`
      report += `â€¢ ì´ ê²Œì„: ${todayMatches.length}ê²Œì„\n`
      report += `â€¢ ìŠ¹ë¦¬: ${wins}ê²Œì„ | íŒ¨ë°°: ${todayMatches.length - wins}ê²Œì„\n`
      report += `â€¢ ìŠ¹ë¥ : ${winRate}%\n`
      if (currentStreak > 0) {
        report += `â€¢ í˜„ì¬ ì—°ìŠ¹: ${currentStreak}ì—°ìŠ¹ âš¡\n`
      }
      report += `\n`

      // ê²Œì„ ëª©ë¡
      report += `ğŸ† ê²Œì„ ê¸°ë¡\n`
      todayMatches.forEach((match, i) => {
        const yourDeck = options.hideDeckNames ? options.deckAlias : match.yourDeck
        const opponentDeck = options.hideOpponentNames ? "ìƒëŒ€" : match.opponentDeck
        const position = match.position === "first" ? "ì„ ê³µğŸš€" : "í›„ê³µğŸ›¡ï¸"
        const result = match.result === "win" ? "ìŠ¹ë¦¬" : "íŒ¨ë°°"
        const resultEmoji = match.result === "win" ? "ğŸŸ¢" : "ğŸ”´"
        const streakText = match.winStreak > 1 ? ` (${match.winStreak}ì—°ìŠ¹!)` : ""

        report += `${i + 1}. ${yourDeck} vs ${opponentDeck} (${position}) â†’ ${result}${resultEmoji}${streakText}\n`
      })
    } else if (!options.showAllTimeStats) {
      report += `ğŸ¯ ì˜¤ëŠ˜ì˜ ì „ì \n`
      report += `ì•„ì§ ê¸°ë¡ëœ ê²Œì„ì´ ì—†ìŠµë‹ˆë‹¤.\n`
    }

    report += `\n${"=".repeat(30)}\n`
    report += `Generated by ${t.appName}`

    return report
  }

  // ë„ë„› ì°¨íŠ¸ ê·¸ë¦¬ê¸° í•¨ìˆ˜
  const drawDonutChart = (
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    radius: number,
    wins: number,
    total: number,
    theme: any,
  ) => {
    if (total === 0) return

    const winRate = wins / total
    const lossRate = 1 - winRate

    // ë°°ê²½ ì›
    ctx.beginPath()
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.fillStyle = theme.bg
    ctx.fill()
    ctx.strokeStyle = theme.border
    ctx.lineWidth = 1
    ctx.stroke()

    // íŒ¨ë°° ë¶€ë¶„ (ì „ì²´)
    ctx.beginPath()
    ctx.arc(x, y, radius - 3, 0, 2 * Math.PI)
    ctx.fillStyle = theme.danger + "30"
    ctx.fill()

    // ìŠ¹ë¦¬ ë¶€ë¶„ (í˜¸)
    if (winRate > 0) {
      ctx.beginPath()
      ctx.arc(x, y, radius - 3, -Math.PI / 2, -Math.PI / 2 + winRate * 2 * Math.PI)
      ctx.strokeStyle = theme.success
      ctx.lineWidth = radius / 4
      ctx.stroke()
    }

    // ì¤‘ì•™ í…ìŠ¤íŠ¸
    ctx.fillStyle = theme.text
    ctx.font = "bold 11px Arial, sans-serif"
    ctx.textAlign = "center"
    ctx.fillText(`${(winRate * 100).toFixed(0)}%`, x, y - 2)

    ctx.font = "8px Arial, sans-serif"
    ctx.fillStyle = theme.textLight
    ctx.fillText(`${wins}ìŠ¹ ${total - wins}íŒ¨`, x, y + 8)
  }

  // íƒ€ì´íŠ¸í•œ ì´ë¯¸ì§€ ë¦¬í¬íŠ¸ ìƒì„±
  const generateImageReport = async (): Promise<string> => {
    return new Promise((resolve) => {
      const canvas = document.createElement("canvas")
      const ctx = canvas.getContext("2d")!

      // ë” ì‘ê³  íƒ€ì´íŠ¸í•œ í¬ê¸°
      canvas.width = 400
      canvas.height = 280

      // ë¯¸ë‹ˆë©€ í…Œë§ˆ ìƒ‰ìƒ
      const theme = {
        bg: "#f8fafc",
        cardBg: "#ffffff",
        primary: "#3b82f6",
        success: "#10b981",
        danger: "#ef4444",
        text: "#1e293b",
        textLight: "#64748b",
        border: "#e2e8f0",
      }

      // ë°°ê²½
      ctx.fillStyle = theme.bg
      ctx.fillRect(0, 0, canvas.width, canvas.height)

      let yPos = 8

      // í—¤ë” (ë” ì‘ê²Œ)
      ctx.fillStyle = theme.cardBg
      ctx.fillRect(8, yPos, canvas.width - 16, 32)
      ctx.strokeStyle = theme.border
      ctx.lineWidth = 1
      ctx.strokeRect(8, yPos, canvas.width - 16, 32)

      ctx.fillStyle = theme.text
      ctx.font = "bold 14px Arial, sans-serif"
      ctx.textAlign = "center"
      ctx.fillText("ğŸ® ì „ì  ë¦¬í¬íŠ¸", canvas.width / 2, yPos + 15)

      ctx.font = "9px Arial, sans-serif"
      ctx.fillStyle = theme.textLight
      const today = new Date().toLocaleDateString("ko-KR")
      ctx.fillText(today, canvas.width / 2, yPos + 27)

      yPos += 40

      const allTimeStats = getAllTimeStats()

      // ì „ì²´ í†µê³„ (ìƒë‹¨, ë” ì‘ê²Œ)
      if (options.showAllTimeStats && allTimeStats) {
        ctx.fillStyle = theme.cardBg
        ctx.fillRect(8, yPos, canvas.width - 16, 50)
        ctx.strokeStyle = theme.border
        ctx.strokeRect(8, yPos, canvas.width - 16, 50)

        ctx.fillStyle = theme.text
        ctx.font = "bold 10px Arial, sans-serif"
        ctx.textAlign = "left"
        ctx.fillText("ğŸ“Š ì „ì²´ í†µê³„", 15, yPos + 12)

        // ë„ë„› ì°¨íŠ¸ (ë” ì‘ê²Œ)
        drawDonutChart(ctx, 50, yPos + 30, 15, allTimeStats.wins, allTimeStats.totalGames, theme)

        // í†µê³„ í…ìŠ¤íŠ¸ (ë” ì••ì¶•)
        ctx.textAlign = "left"
        ctx.font = "9px Arial, sans-serif"
        ctx.fillStyle = theme.text

        const statsX = 80
        ctx.fillText(`ì´ ${allTimeStats.totalGames}ê²Œì„`, statsX, yPos + 20)
        ctx.fillText(`ìŠ¹ë¥  ${allTimeStats.winRate}%`, statsX, yPos + 32)
        ctx.fillText(`ìµœê³  ${allTimeStats.maxStreak}ì—°ìŠ¹ ğŸ”¥`, statsX, yPos + 44)

        yPos += 58
      }

      // ë©”ì¸ ì½˜í…ì¸  ì˜ì—­ (ê°€ë¡œ ë¶„í• , ë” íƒ€ì´íŠ¸)
      const contentHeight = canvas.height - yPos - 15
      const leftWidth = (canvas.width - 24) / 2
      const rightWidth = leftWidth

      // ì™¼ìª½: ì˜¤ëŠ˜ì˜ ì „ì 
      ctx.fillStyle = theme.cardBg
      ctx.fillRect(8, yPos, leftWidth, contentHeight)
      ctx.strokeStyle = theme.border
      ctx.strokeRect(8, yPos, leftWidth, contentHeight)

      ctx.fillStyle = theme.text
      ctx.font = "bold 10px Arial, sans-serif"
      ctx.textAlign = "left"
      ctx.fillText("ğŸ¯ ì˜¤ëŠ˜ì˜ ì „ì ", 15, yPos + 12)

      if (todayMatches.length > 0) {
        const wins = todayMatches.filter((m) => m.result === "win").length
        const winRate = (wins / todayMatches.length) * 100
        const currentStreak = getCurrentStreak()

        // ìŠ¹ë¥  ì›í˜• (ë” ì‘ê²Œ)
        const circleX = 8 + leftWidth / 2
        const circleY = yPos + 45
        const radius = 18

        ctx.beginPath()
        ctx.arc(circleX, circleY, radius, 0, 2 * Math.PI)
        ctx.fillStyle = theme.bg
        ctx.fill()
        ctx.strokeStyle = theme.border
        ctx.lineWidth = 1
        ctx.stroke()

        if (todayMatches.length > 0) {
          const angle = (winRate / 100) * 2 * Math.PI
          ctx.beginPath()
          ctx.arc(circleX, circleY, radius, -Math.PI / 2, -Math.PI / 2 + angle)
          ctx.strokeStyle = winRate >= 50 ? theme.success : theme.danger
          ctx.lineWidth = 2
          ctx.stroke()
        }

        ctx.fillStyle = theme.text
        ctx.font = "bold 11px Arial, sans-serif"
        ctx.textAlign = "center"
        ctx.fillText(`${winRate.toFixed(0)}%`, circleX, circleY - 2)

        ctx.font = "8px Arial, sans-serif"
        ctx.fillStyle = theme.textLight
        ctx.fillText(`${wins}ìŠ¹ ${todayMatches.length - wins}íŒ¨`, circleX, circleY + 8)

        // ê²Œì„ ìˆ˜ì™€ í˜„ì¬ ì—°ìŠ¹ (ë” ì••ì¶•)
        ctx.font = "9px Arial, sans-serif"
        ctx.fillStyle = theme.text
        ctx.fillText(`ì´ ${todayMatches.length}ê²Œì„`, circleX, circleY + 25)

        if (currentStreak > 0) {
          ctx.fillStyle = theme.success
          ctx.fillText(`í˜„ì¬ ${currentStreak}ì—°ìŠ¹!`, circleX, circleY + 37)
        }
      } else {
        ctx.fillStyle = theme.textLight
        ctx.font = "10px Arial, sans-serif"
        ctx.textAlign = "center"
        ctx.fillText("ì•„ì§ ê¸°ë¡ëœ", 8 + leftWidth / 2, yPos + 40)
        ctx.fillText("ê²Œì„ì´ ì—†ìŠµë‹ˆë‹¤", 8 + leftWidth / 2, yPos + 55)
      }

      // ì˜¤ë¥¸ìª½: ê²Œì„ ê¸°ë¡
      const rightX = 16 + leftWidth
      ctx.fillStyle = theme.cardBg
      ctx.fillRect(rightX, yPos, rightWidth, contentHeight)
      ctx.strokeStyle = theme.border
      ctx.strokeRect(rightX, yPos, rightWidth, contentHeight)

      ctx.fillStyle = theme.text
      ctx.font = "bold 10px Arial, sans-serif"
      ctx.textAlign = "left"
      ctx.fillText("ğŸ† ê²Œì„ ê¸°ë¡", rightX + 8, yPos + 12)

      if (todayMatches.length > 0) {
        let gameY = yPos + 22
        const maxGames = Math.min(todayMatches.length, 15)
        const gameHeight = 12

        todayMatches.slice(-maxGames).forEach((match, i) => {
          const yourDeck = options.hideDeckNames ? options.deckAlias : match.yourDeck
          const opponentDeck = options.hideOpponentNames ? "ìƒëŒ€" : match.opponentDeck

          // ê²Œì„ ë°°ê²½ (ë” ì–‡ê²Œ)
          const bgColor = match.result === "win" ? theme.success + "15" : theme.danger + "15"
          ctx.fillStyle = bgColor
          ctx.fillRect(rightX + 3, gameY, rightWidth - 6, gameHeight)

          // ê²°ê³¼ì™€ ì„ í›„ê³µ ì•„ì´ì½˜
          const resultIcon = match.result === "win" ? "ğŸŸ¢" : "ğŸ”´"
          const positionIcon = match.position === "first" ? "ğŸš€" : "ğŸ›¡ï¸"

          ctx.fillStyle = theme.text
          ctx.font = "8px Arial, sans-serif"
          ctx.textAlign = "left"

          // ê²Œì„ ì •ë³´ (ë” ì••ì¶•)
          const gameText = `${resultIcon}${positionIcon} ${yourDeck} vs ${opponentDeck}`
          ctx.fillText(gameText, rightX + 5, gameY + 8)

          // ì—°ìŠ¹ í‘œì‹œ
          if (match.winStreak > 1) {
            ctx.fillStyle = theme.success
            ctx.font = "bold 7px Arial, sans-serif"
            ctx.textAlign = "right"
            ctx.fillText(`${match.winStreak}ì—°ìŠ¹`, rightX + rightWidth - 5, gameY + 8)
          }

          gameY += gameHeight + 1
        })

        if (todayMatches.length > maxGames) {
          ctx.fillStyle = theme.textLight
          ctx.font = "8px Arial, sans-serif"
          ctx.textAlign = "center"
          ctx.fillText(`... ì™¸ ${todayMatches.length - maxGames}ê²Œì„ ë”`, rightX + rightWidth / 2, gameY + 8)
        }
      } else {
        ctx.fillStyle = theme.textLight
        ctx.font = "9px Arial, sans-serif"
        ctx.textAlign = "center"
        ctx.fillText("ê²Œì„ì„ ì‹œì‘í•´ë³´ì„¸ìš”!", rightX + rightWidth / 2, yPos + 40)
      }

      // ì›Œí„°ë§ˆí¬ (ë” ì‘ê²Œ)
      ctx.fillStyle = theme.textLight
      ctx.font = "7px Arial, sans-serif"
      ctx.textAlign = "center"
      ctx.fillText(`Generated by ${t.appName}`, canvas.width / 2, canvas.height - 5)

      resolve(canvas.toDataURL("image/png"))
    })
  }

  // ì˜µì…˜ ë³€ê²½ì‹œ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
  useEffect(() => {
    if (!isOpen) return

    if (activeTab === "text") {
      setTextPreview(generateTextReport())
    } else {
      setIsGenerating(true)
      generateImageReport().then((dataUrl) => {
        setImagePreview(dataUrl)
        setIsGenerating(false)
      })
    }
  }, [options, activeTab, isOpen, todayMatches, allMatches])

  const handleCopyText = async () => {
    try {
      await navigator.clipboard.writeText(textPreview)
      // íŒì—… ì œê±° - ì¡°ìš©íˆ ë³µì‚¬ë§Œ
    } catch (error) {
      console.error("í…ìŠ¤íŠ¸ ë³µì‚¬ ì‹¤íŒ¨:", error)
    }
  }

  const handleDownloadText = () => {
    const blob = new Blob([textPreview], { type: "text/plain;charset=utf-8" })
    const url = URL.createObjectURL(blob)
    const a = document.createElement("a")
    a.href = url
    a.download = `Omegagu_Report_${new Date().toISOString().split("T")[0]}.txt`
    a.click()
    URL.revokeObjectURL(url)
  }

  const handleCopyImage = async () => {
    try {
      const response = await fetch(imagePreview)
      const blob = await response.blob()
      await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })])
      // íŒì—… ì œê±° - ì¡°ìš©íˆ ë³µì‚¬ë§Œ
    } catch (error) {
      console.error("ì´ë¯¸ì§€ ë³µì‚¬ ì‹¤íŒ¨:", error)
    }
  }

  const handleDownloadImage = () => {
    const link = document.createElement("a")
    link.download = `Omegagu_Report_${new Date().toISOString().split("T")[0]}.png`
    link.href = imagePreview
    link.click()
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div
        className={`w-full max-w-5xl h-[90vh] rounded-lg shadow-xl ${settings.theme === "dark" ? "bg-gray-900" : "bg-white"}`}
      >
        <div className="flex h-full">
          {/* ì˜µì…˜ íŒ¨ë„ */}
          <div
            className={`w-64 border-r overflow-y-auto ${settings.theme === "dark" ? "border-gray-700 bg-gray-800" : "border-gray-200"}`}
          >
            <div className="p-4">
              <div className="flex items-center justify-between mb-4">
                <h2 className={`text-lg font-bold ${settings.theme === "dark" ? "text-white" : "text-gray-800"}`}>
                  ë¦¬í¬íŠ¸ ìƒì„±ê¸°
                </h2>
                <Button variant="ghost" size="sm" onClick={onClose}>
                  <X className="h-4 w-4" />
                </Button>
              </div>

              <Tabs value={activeTab} onValueChange={setActiveTab} className="mb-6">
                <TabsList className="grid w-full grid-cols-2">
                  <TabsTrigger value="text">í…ìŠ¤íŠ¸</TabsTrigger>
                  <TabsTrigger value="image">ì´ë¯¸ì§€</TabsTrigger>
                </TabsList>
              </Tabs>

              <div className="space-y-4">
                {/* ì „ì²´ í†µê³„ ì˜µì…˜ */}
                <Card>
                  <CardHeader className="pb-3">
                    <CardTitle className="text-sm flex items-center">
                      <BarChart3 className="h-4 w-4 mr-2" />
                      í†µê³„ ì„¤ì •
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="flex items-center justify-between">
                      <Label htmlFor="show-all-stats" className="text-sm">
                        ì „ì²´ í†µê³„ í‘œì‹œ
                      </Label>
                      <Switch
                        id="show-all-stats"
                        checked={options.showAllTimeStats}
                        onCheckedChange={(checked) => setOptions({ ...options, showAllTimeStats: checked })}
                      />
                    </div>
                    <p className={`text-xs mt-2 ${settings.theme === "dark" ? "text-gray-400" : "text-gray-600"}`}>
                      CSVì— ì €ì¥ëœ ëª¨ë“  ì „ì  í†µê³„ë¥¼ í¬í•¨í•©ë‹ˆë‹¤
                    </p>
                  </CardContent>
                </Card>

                {/* í”„ë¼ì´ë²„ì‹œ ì„¤ì • */}
                <Card>
                  <CardHeader className="pb-3">
                    <CardTitle className="text-sm flex items-center">
                      <Eye className="h-4 w-4 mr-2" />
                      í”„ë¼ì´ë²„ì‹œ ì„¤ì •
                    </CardTitle>
                  </CardHeader>
                  <CardContent className="space-y-4">
                    <div className="flex items-center justify-between">
                      <Label htmlFor="hide-deck" className="text-sm">
                        ë± ì´ë¦„ ìˆ¨ê¸°ê¸°
                      </Label>
                      <Switch
                        id="hide-deck"
                        checked={options.hideDeckNames}
                        onCheckedChange={(checked) => setOptions({ ...options, hideDeckNames: checked })}
                      />
                    </div>
                    {options.hideDeckNames && (
                      <div>
                        <Label htmlFor="deck-alias" className="text-sm">
                          ë± ë³„ëª…
                        </Label>
                        <Input
                          id="deck-alias"
                          value={options.deckAlias}
                          onChange={(e) => setOptions({ ...options, deckAlias: e.target.value })}
                          className="mt-1"
                          placeholder="ì˜ˆ: ë‚´ ë±"
                        />
                      </div>
                    )}
                    <div className="flex items-center justify-between">
                      <Label htmlFor="hide-opponent" className="text-sm">
                        ìƒëŒ€ ì´ë¦„ ìˆ¨ê¸°ê¸°
                      </Label>
                      <Switch
                        id="hide-opponent"
                        checked={options.hideOpponentNames}
                        onCheckedChange={(checked) => setOptions({ ...options, hideOpponentNames: checked })}
                      />
                    </div>
                  </CardContent>
                </Card>
              </div>

              {activeTab === "image" && (
                <div className={`mt-4 p-3 rounded-lg ${settings.theme === "dark" ? "bg-gray-700" : "bg-gray-50"}`}>
                  <p className={`text-xs ${settings.theme === "dark" ? "text-gray-400" : "text-gray-600"}`}>
                    ğŸ’¡ ì´ë¯¸ì§€ëŠ” íƒ€ì´íŠ¸í•œ ê°€ë¡œ ë¶„í•  êµ¬ì¡°ë¡œ ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
                  </p>
                  <p className={`text-xs mt-1 ${settings.theme === "dark" ? "text-gray-400" : "text-gray-600"}`}>
                    ğŸš€ ì„ ê³µ | ğŸ›¡ï¸ í›„ê³µ
                  </p>
                </div>
              )}
            </div>
          </div>

          {/* ë¯¸ë¦¬ë³´ê¸° íŒ¨ë„ */}
          <div className="flex-1 flex flex-col">
            <div className={`p-4 border-b ${settings.theme === "dark" ? "border-gray-700" : "border-gray-200"}`}>
              <div className="flex items-center justify-between">
                <h3 className={`font-semibold ${settings.theme === "dark" ? "text-white" : "text-gray-800"}`}>
                  ë¯¸ë¦¬ë³´ê¸°
                </h3>
                <div className="flex gap-2">
                  <Button onClick={activeTab === "text" ? handleCopyText : handleCopyImage} size="sm">
                    <Copy className="h-4 w-4 mr-1" />
                    ë³µì‚¬
                  </Button>
                  <Button
                    onClick={activeTab === "text" ? handleDownloadText : handleDownloadImage}
                    variant="outline"
                    size="sm"
                  >
                    <Download className="h-4 w-4 mr-1" />
                    ë‹¤ìš´ë¡œë“œ
                  </Button>
                </div>
              </div>
            </div>

            <div className="flex-1 p-4 overflow-auto">
              {activeTab === "text" ? (
                <div
                  className={`w-full h-full p-4 rounded border font-mono text-sm whitespace-pre-wrap ${
                    settings.theme === "dark"
                      ? "bg-gray-800 border-gray-600 text-gray-100"
                      : "bg-gray-50 border-gray-200"
                  }`}
                >
                  {textPreview}
                </div>
              ) : (
                <div className="flex items-center justify-center h-full">
                  {isGenerating ? (
                    <div className="text-center">
                      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"></div>
                      <p className={settings.theme === "dark" ? "text-gray-400" : "text-gray-600"}>ì´ë¯¸ì§€ ìƒì„± ì¤‘...</p>
                    </div>
                  ) : imagePreview ? (
                    <img
                      src={imagePreview || "/placeholder.svg"}
                      alt="Report Preview"
                      className="max-w-full max-h-full object-contain rounded shadow-lg"
                    />
                  ) : null}
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
